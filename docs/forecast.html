---

title: Forecast


keywords: fastai
sidebar: home_sidebar

summary: "This module contains the forecast algorithms for a DGLM. These functions return a set of sampled values from the forecast distribution. Using this sample, PyBATS functions calculate point estimates (means, medians), and uncertainty measures such as credible intervals."
description: "This module contains the forecast algorithms for a DGLM. These functions return a set of sampled values from the forecast distribution. Using this sample, PyBATS functions calculate point estimates (means, medians), and uncertainty measures such as credible intervals."
nb_path: "nbs/02_forecast.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/02_forecast.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Forecasting occurs at time $t$ before a new value $y_t$ has been observed. There are two types of forecasts:</p>
<ol>
<li><strong>Marginal</strong> - A forecast made at <em>k</em> time steps into the future only. For example, marginal forecasting with $k=1$ will simulate from the forecast distribution for $y_t$. Marginal forecasting with $k=2$ will simulate from the forecast distribution for $y_{t+1}$, and so on.</li>
</ol>
<ol>
<li><strong>Path</strong> - A joint forecast made from <em>1</em> to <em>k</em> steps into the future. Path forecasting with $k=3$ will simulate <em>dependent</em> observations $y_t, y_{t+1}, y_{t+2}$. Path forecasting is important when computing functions across multiple forecast horizons. The most common example is forecasting the <em>sum</em> $\sum_{h=1:k} y_{t+k-1}$. This is accomplished by path forecasting $k$ steps ahead, and then summing each path to get a random sample from the forecast distribution for the sum.</li>
</ol>
<p>Naturally, forecasting $k-$steps ahead requires knowing all predictors $X$ that far into the future as well. Marginal forecasting $k-$steps ahead accepts $X_{t+k-1}$ as an argument. Path forecasting accepts the predictors in an array. Each row contains the predictors at one time step, starting with $X_t$ in the first row, down to $X_{t+k-1}$ in the last row.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Marginal-Forecasting">Marginal Forecasting<a class="anchor-link" href="#Marginal-Forecasting"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="forecast_marginal" class="doc_header"><code>forecast_marginal</code><a href="https://github.com/lavinei/pybats/tree/master/pybats/forecast.py#L39" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>forecast_marginal</code>(<strong><code>mod</code></strong>, <strong><code>k</code></strong>, <strong><code>X</code></strong>=<em><code>None</code></em>, <strong><code>nsamps</code></strong>=<em><code>1</code></em>, <strong><code>mean_only</code></strong>=<em><code>False</code></em>, <strong><code>state_mean_var</code></strong>=<em><code>False</code></em>, <strong><code>y</code></strong>=<em><code>None</code></em>)</p>
</blockquote>
<p>Marginal forecast function k steps ahead</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This marginal forecast method works for Poisson and Bernoulli DGLMs. Below we run through a basic usage with the following steps:</p>
<ul>
<li>Manually define a simple DGLM with an intercept and 2 regression predictors</li>
<li>Define the future predictors, $X_{t+k-1}$</li>
<li>Forecast by drawing a random sample at $k=5$, and getting a $95\%$ credible interval</li>
<li>Forecast the mean only, without drawing a random sample</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pybats.dglm</span> <span class="kn">import</span> <span class="n">dlm</span><span class="p">,</span> <span class="n">pois_dglm</span><span class="p">,</span> <span class="n">bern_dglm</span><span class="p">,</span> <span class="n">bin_dglm</span>
<span class="kn">from</span> <span class="nn">pybats.analysis</span> <span class="kn">import</span> <span class="n">analysis</span>

<span class="c1"># Define Poisson and Bernoulli DGLMs, along with a normal DLM, with 1 trend term and 2 regression predictors</span>
<span class="n">a0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">R0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mi">10</span>
<span class="n">mod_n</span> <span class="o">=</span> <span class="n">dlm</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">ntrend</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nregn</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">deltrend</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">delregn</span><span class="o">=.</span><span class="mi">9</span><span class="p">,</span> <span class="n">discount_forecast</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">mod_p</span> <span class="o">=</span> <span class="n">pois_dglm</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">ntrend</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nregn</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">deltrend</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">delregn</span><span class="o">=.</span><span class="mi">9</span><span class="p">)</span>
<span class="n">mod_bern</span> <span class="o">=</span> <span class="n">bern_dglm</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">ntrend</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nregn</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">deltrend</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">delregn</span><span class="o">=.</span><span class="mi">9</span><span class="p">)</span>

<span class="c1"># New predictors for k=5 steps into the future</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>First we're going to forecast from the Poisson DGLM, which will draw a random sample from the forecast distribution. We'll use the forecast samples to calculate a $95\%$ credible interval.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">forecast_samples</span> <span class="o">=</span> <span class="n">mod_p</span><span class="o">.</span><span class="n">forecast_marginal</span><span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">nsamps</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>

<span class="c1"># Get the 95% credible intervals</span>
<span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">forecast_samples</span><span class="p">,</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">97.5</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>array([  9., 193.])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can repeat this analysis using the normal DLM:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">forecast_samples</span> <span class="o">=</span> <span class="n">mod_n</span><span class="o">.</span><span class="n">forecast_marginal</span><span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">nsamps</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>

<span class="c1"># Get the 95% credible intervals</span>
<span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">forecast_samples</span><span class="p">,</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">97.5</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>array([-15.38467317,  19.76701873])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Next we'll test the models by setting <code>mean_only=True</code>. This will return only the mean value, without simulation from the forecast distribution. It is much faster if the mean is the only value of interest.</p>
<p>Notice that we skipped simulating from the Bernoulli DGLM, because Bernoulli outcomes are only $0$ or $1$ anyway. The mean of the forecast distribution in a Bernoulli DGLM is equal to the probability of the outcome being $1$.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Setting the flag mean_only=True returns the exact mean, without simulation</span>

<span class="n">m_p</span> <span class="o">=</span> <span class="n">mod_p</span><span class="o">.</span><span class="n">forecast_marginal</span><span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">mean_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ans</span> <span class="o">=</span> <span class="p">[</span><span class="mf">70.38455503971952</span><span class="p">]</span>
<span class="k">assert</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ans</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">5</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">m_p</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>

<span class="c1"># Test the Bernoulli DGLM forecast mean is correct</span>
<span class="c1"># Setting the flag mean_only=True returns the exact mean, without simulation</span>

<span class="n">m_bern</span> <span class="o">=</span> <span class="n">mod_bern</span><span class="o">.</span><span class="n">forecast_marginal</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">mean_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ans</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.9771442828394032</span><span class="p">]</span>
<span class="k">assert</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ans</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">5</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">m_bern</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>

<span class="c1"># Test the Bernoulli DGLM forecast mean is correct</span>
<span class="c1"># Setting the flag state_mean_var=True returns the exact mean and variance, without simulation</span>

<span class="n">m_n</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">mod_n</span><span class="o">.</span><span class="n">forecast_marginal</span><span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">state_mean_var</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ans</span> <span class="o">=</span> <span class="p">[</span><span class="mf">4.</span><span class="p">,</span> <span class="mf">1.82222222</span><span class="p">]</span>
<span class="k">assert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ans</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">5</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">m_n</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>
<span class="k">assert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ans</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">5</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><a href="/pybats/dglm.html#dglm.forecast_marginal"><code>dglm.forecast_marginal</code></a> has three special features beyond returning just a random sample from the forecast distribution:</p>
<ol>
<li>Setting <code>mean_only = True</code> makes the function return the mean of the forecast distribution, instead of a random sample.</li>
<li>Setting <code>state_mean_and_var = True</code> makes the function return the mean and variance of the linear predictor, $\lambda_t = F_t^{'} \theta_t$.</li>
<li>Passing in a value for <code>y</code> makes the function return the <em>log</em> probability density of <code>y</code> under the forecast distribution, $p(y)$.</li>
</ol>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="forecast_marginal_bindglm" class="doc_header"><code>forecast_marginal_bindglm</code><a href="https://github.com/lavinei/pybats/tree/master/pybats/forecast.py#L68" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>forecast_marginal_bindglm</code>(<strong><code>mod</code></strong>, <strong><code>n</code></strong>, <strong><code>k</code></strong>, <strong><code>X</code></strong>=<em><code>None</code></em>, <strong><code>nsamps</code></strong>=<em><code>1</code></em>, <strong><code>mean_only</code></strong>=<em><code>False</code></em>)</p>
</blockquote>
<p>Marginal forecast function k steps ahead for a binomial DGLM</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We'll repeat the same tests from above on a binomial DGLM by specifying both the predictors <code>X</code> and the number of trials <code>n</code>.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">mod_b</span> <span class="o">=</span> <span class="n">bin_dglm</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">ntrend</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nregn</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">deltrend</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">delregn</span><span class="o">=.</span><span class="mi">9</span><span class="p">)</span>

<span class="c1"># Test the Binomial DGLM</span>
<span class="n">m_bin</span> <span class="o">=</span> <span class="n">mod_b</span><span class="o">.</span><span class="n">forecast_marginal</span><span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">mean_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ans</span> <span class="o">=</span> <span class="p">[</span><span class="mf">9.771442828394033</span><span class="p">]</span>
<span class="k">assert</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ans</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">5</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">m_bin</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Path-forecasting">Path forecasting<a class="anchor-link" href="#Path-forecasting"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="forecast_path" class="doc_header"><code>forecast_path</code><a href="https://github.com/lavinei/pybats/tree/master/pybats/forecast.py#L113" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>forecast_path</code>(<strong><code>mod</code></strong>, <strong><code>k</code></strong>, <strong><code>X</code></strong>=<em><code>None</code></em>, <strong><code>nsamps</code></strong>=<em><code>1</code></em>)</p>
</blockquote>
<p>Path forecast function k steps ahead using sequential simulation</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="forecast_path_copula" class="doc_header"><code>forecast_path_copula</code><a href="https://github.com/lavinei/pybats/tree/master/pybats/forecast.py#L165" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>forecast_path_copula</code>(<strong><code>mod</code></strong>, <strong><code>k</code></strong>, <strong><code>X</code></strong>=<em><code>None</code></em>, <strong><code>nsamps</code></strong>=<em><code>1</code></em>, <strong><code>t_dist</code></strong>=<em><code>False</code></em>, <strong><code>y</code></strong>=<em><code>None</code></em>, <strong><code>nu</code></strong>=<em><code>9</code></em>, <strong><code>return_cov</code></strong>=<em><code>False</code></em>)</p>
</blockquote>
<p>Path forecast function k steps ahead using a copula model</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="forecast_path_dlm" class="doc_header"><code>forecast_path_dlm</code><a href="https://github.com/lavinei/pybats/tree/master/pybats/forecast.py#L214" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>forecast_path_dlm</code>(<strong><code>mod</code></strong>, <strong><code>k</code></strong>, <strong><code>X</code></strong>=<em><code>None</code></em>, <strong><code>nsamps</code></strong>=<em><code>1</code></em>, <strong><code>approx</code></strong>=<em><code>True</code></em>)</p>
</blockquote>
<p>Path forecast function k steps ahead for a DLM</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>There are two functions for path forecasting with DGLMs. <a href="/pybats/forecast.html#forecast_path_copula"><code>forecast_path_copula</code></a> is the default method, and is part of my new <a href="https://arxiv.org/pdf/2007.04956.pdf">research</a>. It dramatically speeds up path forecasting in DGLMs. The traditional <a href="/pybats/forecast.html#forecast_path"><code>forecast_path</code></a> function is only used when <a href="/pybats/dglm.html#dglm.forecast_path"><code>dglm.forecast_path</code></a> is called with the flag <code>copula=FALSE</code>.</p>
<p>Below we'll test path forecasting - with a copula, as is the default - for $k=2$ steps into the future. The Poisson model will have $2$ trend terms - an intercept and a slope - and 1 regression term. This test will confirm that marginal forecasting and path forecasting lead to identical forecast means for $k=1$ and $k=2$ steps ahead.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">a0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">R0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mi">100</span>
<span class="n">mod_p</span> <span class="o">=</span> <span class="n">pois_dglm</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">ntrend</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nregn</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">deltrend</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">delregn</span><span class="o">=.</span><span class="mi">9</span><span class="p">)</span>

<span class="c1"># The predictors for the next 2 time steps, X_t and X_(t+1), in a matrix with k=2 rows</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">]])</span>

<span class="c1"># Test the Poisson DGLM by comparing the path and marginal forecast distributions</span>
<span class="n">samps_copula</span> <span class="o">=</span> <span class="n">mod_p</span><span class="o">.</span><span class="n">forecast_path_copula</span><span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">nsamps</span><span class="o">=</span><span class="mi">100000</span><span class="p">)</span>
<span class="n">m_samp</span> <span class="o">=</span> <span class="n">samps_copula</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">m_marg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mod_p</span><span class="o">.</span><span class="n">forecast_marginal</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mean_only</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
          <span class="n">mod_p</span><span class="o">.</span><span class="n">forecast_marginal</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mean_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="k">assert</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">m_samp</span> <span class="o">-</span> <span class="n">m_marg</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>

<span class="n">samps_path</span> <span class="o">=</span> <span class="n">mod_p</span><span class="o">.</span><span class="n">forecast_path</span><span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">nsamps</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">copula</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">m_samp</span> <span class="o">=</span> <span class="n">samps_path</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="k">assert</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">m_samp</span> <span class="o">-</span> <span class="n">m_marg</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><a href="/pybats/dglm.html#dglm.forecast_path"><code>dglm.forecast_path</code></a> has two special features beyond returning just a random sample from the forecast distribution. These only work when using <a href="/pybats/forecast.html#forecast_path_copula"><code>forecast_path_copula</code></a>, and are not yet available for a normal DLM.</p>
<ol>
<li>Passing in a value (a vector of length $k$) for <code>y</code> makes the function return the <em>log</em> probability density of <code>y</code> under the forecast distribution, $p(y)$.</li>
<li>Setting <code>return_cov = True</code> makes the function return the covariance in the copula distribution. This will be different than the covariance in the forecast distribution, which can be calculated directly from a random sample.</li>
</ol>

</div>
</div>
</div>
</div>
 

