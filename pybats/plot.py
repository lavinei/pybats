# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/09_plot.ipynb (unless otherwise specified).

__all__ = ['ax_style', 'plot_data_forecast', 'plot_coef', 'plot_corr']

# Internal Cell
#exporti
import matplotlib.pyplot as plt
import numpy as np
from datetime import datetime, date
import seaborn as sns
from pandas.plotting import register_matplotlib_converters
register_matplotlib_converters()

# Cell
def ax_style(ax, ylim=None, xlim=None, xlabel=None, ylabel=None, title=None,
             legend=None, legend_inside_plot=True, topborder=False, rightborder=False, **kwargs):
    """
    A helper function to define many elements of axis style at once.
    """

    if legend is not None:
        if legend_inside_plot:
            ax.legend(legend)
        else:
            ax.legend(legend, bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.5, frameon=False)
            # Make room for the legend
            plt.subplots_adjust(right=.85)

    if ylim is not None: ax.set_ylim(ylim)
    if xlim is not None: ax.set_xlim(xlim)
    if xlabel is not None: ax.set_xlabel(xlabel)
    if ylabel is not None: ax.set_ylabel(ylabel)
    if title is not None: ax.set_title(title)

    # remove the top and right borders
    ax.spines['top'].set_visible(topborder)
    ax.spines['right'].set_visible(rightborder)

    plt.tight_layout()

    return ax

# Cell
# Plot Data vs Forecast (with credible intervals)
def plot_data_forecast(fig, ax, y, f, samples, dates, linewidth=.5, linecolor='b', credible_interval=95, **kwargs):
    """
    Plot observations along with sequential forecasts and credible intervals.
    Adjusted to apply cubic spline to smooth the curves
    Added density function to fill area of confidence intervals
    """

    # Predictions with cubic spline for smoothing
    pred_cubic_func = interp1d(dates, f.ravel(), kind='cubic')
    x_pred = np.linspace(start=0, stop=len(dates)-1, num=200)
    pc = pred_cubic_func(x_pred)
    ax.plot(x_pred, pc, color='white', linewidth=linewidth)
    
    alpha = (100 - credible_interval) / 2
    
    # NEW :: for probabilistic CI in plot ####################
    ar = np.arange(0, 101, 1)
    for i in ar:
        alpha = (100-i)/2
    
        upper = np.percentile(samples, [100-alpha], axis=0).reshape(-1)
        lower = np.percentile(samples, [alpha], axis=0).reshape(-1)
        u_cubic = interp1d(dates, upper, kind='cubic')
        l_cubic = interp1d(dates, lower, kind='cubic')
        yu = u_cubic(x_pred)
        yl = l_cubic(x_pred)
        ax.fill_between(x_pred, yu, yl, alpha=.01, color=linecolor)
    #Actuals with cubic splie for smoothing
    act_cubic_func = interp1d(dates, y, kind='cubic')
    act_c = act_cubic_func(x_pred)
    ax.plot(x_pred, act_c, color='black', linewidth=.5)
    ax.scatter(dates, y, color='black')

    if kwargs.get('xlim') is None:
        kwargs.update({'xlim':[dates[0], dates[-1]]})

    if kwargs.get('legend') is None:
        legend = ['Forecast', 'Observations', 'Credible Interval']

    ax = ax_style(ax, legend=legend, **kwargs)

    # If dates are actually dates, then format the dates on the x-axis
    if isinstance(dates[0], (datetime, date)):
        fig.autofmt_xdate()

    return ax

# Cell

def plot_coef(fig, ax, coef, dates, linewidth=1, linecolor=None, legend_inside_plot=True, coef_samples=None, **kwargs):
    """
    Plot coefficients over time.
    """

    if linecolor is not None:
        ax.plot(dates, coef, linewidth=linewidth, color=linecolor)
    else:
        ax.plot(dates, coef, linewidth=linewidth)

    # If dates are actually dates, then format the dates on the x-axis
    if isinstance(dates[0], (datetime, date)):
        fig.autofmt_xdate()

    ax = ax_style(ax, legend_inside_plot=legend_inside_plot, **kwargs)

    # Add credible intervals if samples are provided
    if coef_samples is not None:
        upper = np.percentile(coef_samples, [97.5], axis=0).reshape(-1)
        lower = np.percentile(coef_samples, [2.5], axis=0).reshape(-1)
        ax.fill_between(dates, upper, lower, alpha=.3, color=linecolor)


    # Include the y-axis labels on all subplots, which is not the matplotlib default
    ax.tick_params(labelleft=True)

    return ax

# Cell
def plot_corr(fig, ax, corr, labels=None):
    """
    Plot a correlation matrix with a heatmap.
    """

    ax = sns.heatmap(corr, vmin=-1, vmax=1, center=0,
                       cmap=sns.diverging_palette(10, 240, as_cmap=True),
                       cbar=True,
                       square=True, ax=ax,
                       xticklabels=labels,
                       yticklabels=labels)
    ax.set_xticklabels(labels=labels, rotation=45, size=9)
    ax.set_yticklabels(labels=labels, rotation=0, size=9)
    return ax
