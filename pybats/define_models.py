# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/03_define_models.ipynb (unless otherwise specified).

__all__ = ['define_dglm', 'define_dlm_params', 'define_bern_params', 'define_bin_params', 'define_pois_params',
           'define_dcmm', 'define_dbcm']

# Internal Cell
#exporti
import numpy as np

from .dbcm import dbcm
from .dcmm import dcmm
from .dglm import dlm, pois_dglm, bern_dglm, bin_dglm

import statsmodels.api as sm

# Cell
def define_dglm(Y, X, family="normal", n=None,
                ntrend=1, nlf=0, nhol=0,
                seasPeriods=[7], seasHarmComponents = [[1, 2, 3]],
                deltrend = .995, delregn =.995, delseas = .999, dellf=.999, delVar = 0.999, delhol=1,
                n0 = 1, s0 = 1,
                a0=None, R0=None,
                adapt_discount='info', discount_forecast=False,
                prior_length=None, return_aR=False,
                **kwargs):
    """
    A helper function to define a DGLM.

    This function is especially useful if you do not know how to specifify a prior mean and variance (a0, R0) for the state vector.
    """

    if a0 is None or R0 is None:
        # Inferring the number of observations to use for the prior
        if prior_length is not None:
            n_obs = prior_length
        else:
            n_obs = len(Y)

        # Adding an intercept to the X matrix, if it doesn't already exist
        if X is None and ntrend >= 1:
            X_withintercept = np.ones([n_obs, 1])
        elif ntrend >= 1:
            if len(X.shape) == 1:
                X = X.reshape(-1,1)

            if not np.all(X[:,0] == 1):
                X_withintercept = np.c_[np.ones([n_obs, 1]), X[:n_obs]]
            else:
                X_withintercept = X[:n_obs]

        # Selecting only the correct number of observations (relevant if prior_length is given)
        Y = Y[:n_obs]
        if n is not None:
            n = n[:n_obs]

        # Infer the number of regression and holiday components
        nregn = ncol(X_withintercept) - nhol - 1
        nseas = 2 * sum(map(len, seasHarmComponents))

        # Learn a prior based on the first 'prior_length' observations
        if family == "normal":
            prior_mean, prior_cov, p = define_dlm_params(Y, X_withintercept)
        elif family == "poisson":
            prior_mean, prior_cov, p = define_pois_params(Y, X_withintercept)
        elif family == "bernoulli":
            prior_mean, prior_cov, p = define_bern_params(Y, X_withintercept)
        elif family == "binomial":
            prior_mean, prior_cov, p = define_bin_params(Y, n, X_withintercept)

        # Define a standard prior - setting latent factor priors at 1
        # Unless prior mean (a0) and prior variance (R0) are supplied as arguments
        prior = [[prior_mean[0]], [0] * (ntrend - 1), [*prior_mean[1:]], [0] * nseas, [1] * nlf]
        if a0 is None:
            a0 = np.array([m for ms in prior for m in ms]).reshape(-1, 1)
        if R0 is None:
            R0 = np.identity(a0.shape[0])
            idx = [i for i in range(p + ntrend - 1)]
            for j in range(1, ntrend):
                idx.pop(j)
            R0[np.ix_(idx, idx)] = prior_cov

        # Add variance to holiday indicators - few observations, may be significantly different than other days
        ihol = range(ntrend + nregn, ntrend + nregn + nhol)
        for idx in ihol:
            R0[idx, idx] = R0[idx, idx] * 2
    else:
        # Infer the number of regression and holiday components
        p = len(a0)
        nseas = 2 * sum(map(len, seasHarmComponents))
        nregn = p - ntrend - nhol - nseas - nlf


    if return_aR:
        return a0, R0, nregn

    if kwargs.get('rho') is not None:
        rho = kwargs.get('rho')
    else:
        rho = 1

    if family == "normal":
        mod = dlm(a0=a0, R0=R0,
                  nregn=nregn,
                  ntrend=ntrend,
                  nlf=nlf,
                  nhol=nhol,
                  seasPeriods=seasPeriods,
                  seasHarmComponents=seasHarmComponents,
                  deltrend=deltrend, delregn=delregn,
                  delseas=delseas, delhol=delhol,
                  dellf=dellf,
                  n0=n0, s0=s0, delVar=delVar,
                  adapt_discount=adapt_discount,
                  discount_forecast = discount_forecast)
    elif family == "poisson":
        mod = pois_dglm(a0=a0, R0=R0,
                        nregn=nregn,
                        ntrend=ntrend,
                        nlf=nlf,
                        nhol=nhol,
                        seasPeriods=seasPeriods,
                        seasHarmComponents=seasHarmComponents,
                        deltrend=deltrend, delregn=delregn,
                        delseas=delseas, delhol=delhol,
                        dellf=dellf,
                        adapt_discount=adapt_discount,
                        discount_forecast = discount_forecast,
                        rho = rho)
    elif family == "bernoulli":
        mod = bern_dglm(a0=a0, R0=R0,
                        nregn=nregn,
                        ntrend=ntrend,
                        nlf=nlf,
                        nhol=nhol,
                        seasPeriods=seasPeriods,
                        seasHarmComponents=seasHarmComponents,
                        deltrend=deltrend, delregn=delregn,
                        delseas=delseas, delhol=delhol,
                        dellf=dellf,
                        adapt_discount=adapt_discount,
                        discount_forecast = discount_forecast,
                        rho=rho)
    elif family == "binomial":
        mod = bin_dglm(a0=a0, R0=R0,
                       nregn=nregn,
                       ntrend=ntrend,
                       nlf=nlf,
                       nhol=nhol,
                       seasPeriods=seasPeriods,
                       seasHarmComponents=seasHarmComponents,
                       deltrend=deltrend, delregn=delregn,
                       delseas=delseas, delhol=delhol,
                       dellf=dellf,
                       adapt_discount=adapt_discount,
                       discount_forecast = discount_forecast,
                       rho=rho)


    return mod

# Cell
def define_dlm_params(Y, X=None):
    n = len(Y)
    p = ncol(X)
    g = max(2, int(n / 2))

    linear_mod = sm.OLS(Y, X).fit()

    dlm_mean = linear_mod.params
    dlm_cov = fill_diag((g / (1 + g)) * linear_mod.cov_params())

    return dlm_mean, dlm_cov, p

# Cell
def define_bern_params(Y, X=None):
    n = len(Y)
    p = ncol(X)

    nonzeros = Y.nonzero()[0]

    g = max(2, int(n/2))
    try:
        Y_bern = np.c_[np.zeros([n, 1]), np.ones([n, 1])]
        Y_bern[Y.nonzero()[0], 0] = 1
        Y_bern[Y.nonzero()[0], 1] = 0
        bern_mod = sm.GLM(endog=Y_bern, exog=X, family=sm.families.Binomial()).fit()
        bern_params = bern_mod.params
        bern_cov = fill_diag((g/(1+g))*bern_mod.cov_params())
    except:
        if len(nonzeros) > 0:
            bernmean = len(nonzeros) / (n + 1)
            bernmean = np.log(bernmean / (1 - bernmean))
            bern_params = np.zeros(p)
            bern_params[0] = bernmean
        else:
            bern_params = np.zeros(p)
        bern_cov = np.identity(p)

    return bern_params, bern_cov, p

# Cell
def define_bin_params(Y, n, X=None):
    n_obs = len(Y)
    p = ncol(X)

    g = max(2, int(n_obs / 2))
    try:
        bin_mod = sm.GLM(endog=np.c_[Y, n], exog=X, family=sm.families.Binomial()).fit()
        bin_params = bin_mod.params
        bin_cov = fill_diag((g/(1+g))*bin_mod.cov_params())
    except:
        if np.sum(Y) > 0:
            binmean = np.sum(Y) / np.sum(n)
            binmean = np.log(binmean / (1 - binmean))
            bin_params = np.zeros(p)
            bin_params[0] = binmean
        else:
            bin_params = np.zeros(p)
            bin_params[0] = np.max([-3, -np.sum(n)])
        bin_cov = np.identity(p)

    return bin_params, bin_cov, p

# Cell
def define_pois_params(Y, X=None):
    n = len(Y)
    p = ncol(X)

    g = max(2, int(n/2))
    try:
        pois_mod = sm.GLM(Y, X,
                          family=sm.families.Poisson()).fit()
        pois_params = pois_mod.params
        pois_cov = fill_diag((g/(1+g))*pois_mod.cov_params())
    except:
        pois_params = np.zeros(p)
        pois_cov = np.identity(p)

    return pois_params, pois_cov, p

# Internal Cell
def ncol(x):
    if x is None:
        return 0
    if len(np.shape(x)) == 1:
        return 1
    else:
        return np.shape(x)[1]

# Internal Cell
def fill_diag(cov):
    diag = cov.diagonal().copy()
    diag[diag == 0] = 1
    np.fill_diagonal(cov, diag)
    return cov

# Cell
def define_dcmm(Y, X,
                ntrend=1, nlf=0, nhol = 0, rho=1,
                seasPeriods = [7], seasHarmComponents = [[1,2,3]],
                deltrend_bern=.995, delregn_bern=.995, delseas_bern=.995, dellf_bern=.999, delhol_bern=1,
                deltrend_pois=.998, delregn_pois=.995, delseas_pois=.995, dellf_pois=.999, delhol_pois=1,
                a0_bern = None, R0_bern = None, a0_pois = None, R0_pois = None,
                interpolate=True, adapt_discount=False, prior_length = None,
                **kwargs):
    """
    A helper function to define a DCMM.

    """

    nonzeros = Y.nonzero()[0]
    pois_mod = define_dglm(Y[nonzeros] - 1, X[nonzeros], family="poisson", ntrend=ntrend, nlf=nlf, nhol=nhol,
                              seasPeriods=seasPeriods, seasHarmComponents=seasHarmComponents,
                              a0=a0_pois, R0=R0_pois, prior_length=prior_length)
    bern_mod = define_dglm(Y, X, family="bernoulli", ntrend=ntrend, nlf=nlf, nhol=nhol,
                              seasPeriods=seasPeriods, seasHarmComponents=seasHarmComponents,
                              a0=a0_bern, R0=R0_bern, prior_length=prior_length)



    mod = dcmm(a0_bern = bern_mod.a, R0_bern = bern_mod.R,
               nregn_bern = bern_mod.nregn_exhol,
               ntrend_bern = bern_mod.ntrend,
               nlf_bern= bern_mod.nlf,
               nhol_bern=bern_mod.nhol,
               seasPeriods_bern = bern_mod.seasPeriods,
               seasHarmComponents_bern = bern_mod.seasHarmComponents,
               deltrend_bern = deltrend_bern, delregn_bern = delregn_bern,
               delseas_bern = delseas_bern,
               dellf_bern=dellf_bern,
               delhol_bern = delhol_bern,
               a0_pois = pois_mod.a, R0_pois = pois_mod.R,
               nregn_pois = pois_mod.nregn_exhol,
               ntrend_pois = pois_mod.ntrend,
               nlf_pois=pois_mod.nlf,
               nhol_pois=pois_mod.nhol,
               seasPeriods_pois = pois_mod.seasPeriods,
               seasHarmComponents_pois = pois_mod.seasHarmComponents,
               deltrend_pois = deltrend_pois, delregn_pois = delregn_pois,
               delseas_pois = delseas_pois,
               dellf_pois=dellf_pois,
               delhol_pois = delhol_pois,
               rho = rho,
               interpolate=interpolate,
               adapt_discount=adapt_discount
               )

    return mod

# Cell
def define_dbcm(Y_transaction, X_transaction=None, Y_cascade=None, X_cascade=None, excess_baskets=[], excess_values=[],
                ntrend=1, nlf=0, nhol=0, rho=1,
                seasPeriods=[7], seasHarmComponents=[[1, 2, 3]],
                deltrend_bern=.995, delregn_bern=.995, delseas_bern=.995, dellf_bern=.999, delhol_bern=1,
                deltrend_pois=.998, delregn_pois=.995, delseas_pois=.995, dellf_pois=.999, delhol_pois=1,
                deltrend_cascade=.999, delregn_cascade=1., delseas_cascade=.999, dellf_cascade=.999, delhol_cascade=1.,
                a0_bern=None, R0_bern=None, a0_pois=None, R0_pois=None, a0_cascade=None, R0_cascade=None,
                interpolate=True, adapt_discount=False, prior_length=None,
                **kwargs):
    """
    A helper function to define a DBCM.
    """

    # Define the dcmm
    mod_dcmm = define_dcmm(Y = Y_transaction, X = X_transaction,
                           ntrend=ntrend, nlf=nlf, nhol=nhol, rho=rho,
                           seasPeriods=seasPeriods, seasHarmComponents=seasHarmComponents,
                           deltrend_bern=deltrend_bern, delregn_bern=delregn_bern, delseas_bern=delseas_bern,
                           dellf_bern=dellf_bern, delhol_bern = delhol_bern,
                           deltrend_pois=deltrend_pois, delregn_pois=delregn_pois, delseas_pois=delseas_pois,
                           dellf_pois=dellf_pois, delhol_pois=delhol_pois,
                           a0_bern=a0_bern, R0_bern=R0_bern, a0_pois=a0_pois, R0_pois=R0_pois,
                           interpolate=interpolate, adapt_discount=adapt_discount, prior_length=prior_length)

    # Calculate the prior means for the Cascade
    def cascade_prior_mean(alpha, beta):
        alpha += 1
        beta += 1
        mean = alpha / (alpha + beta)
        logit_mean = np.log(mean / (1 - mean))
        return logit_mean

    # Calculate the prior means for the cascades
    if prior_length is not None:
        if prior_length > 0:

            ncascade = Y_cascade.shape[1]
            nregn_cascade = ncol(X_cascade)
            ntrend_cascade = 1
            pcascade = nregn_cascade + ntrend_cascade

            Yc = np.c_[Y_transaction, Y_cascade]
            nonan = ~np.any(np.isnan(Yc), axis=1)
            Yc = np.sum(Yc[:prior_length][nonan[:prior_length]], axis=0)
            means = [cascade_prior_mean(Yc[i + 1], Yc[i] - Yc[i + 1]) for i in range(ncascade)]
            a0_cascade = [np.zeros(pcascade).reshape(-1, 1) for i in range(ncascade)]
            for i, m in enumerate(means):
                a0_cascade[i][0] = m
            R0_cascade = [0.1 * np.identity(pcascade) for i in range(ncascade)]

            # Initialize empirically observed excess baskets
            excess = []
            if len(excess_values) == 0 and len(excess_baskets) > 0:
                counts = np.sum(excess_baskets[:prior_length, :], axis=0)
                counts[:len(counts) - 1] = counts[:len(counts) - 1] - counts[1:]
                for val, count in enumerate(counts):
                    excess.extend([val + ncascade + 1 for c in range(count)])
            else:
                for e in excess_values[:prior_length]:
                    excess.extend(e)
    else:
        if a0_cascade is None:
            if kwargs.get('pcascade') is None:
                nregn_cascade = ncol(X_cascade)
                ntrend_cascade = 1
                pcascade = nregn_cascade + ntrend_cascade
            else:
                pcascade = kwargs.get('pcascade')
            if kwargs.get('ncascade') is None:
                ncascade = Y_cascade.shape[1]
            else:
                ncascade = kwargs.get('ncascade')

            a0_cascade = [np.zeros(pcascade).reshape(-1, 1) for i in range(ncascade)]
        else:
            nregn_cascade = len(a0_cascade) - 1
            ntrend_cascade = 1

        if R0_cascade is None:
            if kwargs.get('pcascade') is None:
                nregn_cascade = ncol(X_cascade)
                ntrend_cascade = 1
                pcascade = nregn_cascade + ntrend_cascade
            else:
                pcascade = kwargs.get('pcascade')
            if kwargs.get('ncascade') is None:
                ncascade = Y_cascade.shape[1]
            else:
                ncascade = kwargs.get('ncascade')

            R0_cascade = [0.1 * np.identity(pcascade) for i in range(ncascade)]

        excess = []


    # Define the model
    mod = dbcm(mod_dcmm=mod_dcmm,
               ncascade=ncascade,
               a0_cascade=a0_cascade,  # List of length ncascade
               R0_cascade=R0_cascade,  # List of length ncascade
               nregn_cascade=nregn_cascade,
               ntrend_cascade=1,
               nlf_cascade=0,
               seasPeriods_cascade=[],
               seasHarmComponents_cascade=[],
               deltrend_cascade=deltrend_cascade, delregn_cascade=delregn_cascade,
               delseas_cascade=delseas_cascade, dellf_cascade=dellf_cascade, delhol_cascade=delhol_cascade,
               excess=excess)

    return mod